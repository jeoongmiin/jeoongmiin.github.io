# 19일차 TIL

## this : 자바에서 현재 객체를 참조하는 키워드

`this`는 인스턴스 메서드 내에서 사용되며, 해당 메서드를 호출한 객체 자신을 가리킨다. `this`를 사용하여 현재 객체의 멤버 변수와 메서드에 접근할 수 있다.

`this` 키워드의 주요 용도:

1. 현재 객체의 멤버 변수에 접근하기 위해 사용된다. 같은 이름을 가진 지역 변수와 멤버 변수가 있는 경우, `this`를 사용하여 멤버 변수에 접근할 수 있다.
2. 현재 객체의 다른 메서드를 호출하기 위해 사용된다. `this`를 사용하여 현재 객체의 다른 메서드를 호출할 수 있다.

## final 필드

final 필드가 초기값 지정이되면 이것이 최종적인 값이 되어, 프로그램 실행 도중에 수정할 수 없다.

```java
final 타입 필드명 [= 초기값];
```

final 필드의 초기값을 줄 수 있는 방법

- 필드 선언시
- 생성자 에서 초기화

단순 값이라면 필드 선언 시 초기화를 하는 것이 가장 간단하지만 객체 생성 시 외부 데이터로 초기화해야 한다면 생성자에서 초기값을 지정해야 한다. 만약 초기화되지 않은 final 필드를 그대로 남겨두면 컴파일 에러가 발생한다.

## 상수(static final)

원주율 파이, 지구의 무게 및 둘레와 같은 불변의 값을 저장하는 필드를 자바에서는 `상수`라고 한다. final 필드는 한 번만 초기화되면 수정할 수 없지만, final 필드를 상수라고 부르지는 않는다. 왜냐하면 상수는 객체 마다 저장할 필요가 없는 공용성을 띠고 있는 특징이 있고, 여러 가지 값으로 초기화될 수 없기 때문이다. final 필드는 객체마다 저장되고 생성자 매개변수로 여러가지 값을 가질 수 있기 때문에 상수가 될 수 없다. 

```java
static final 타입 상수 [= 초기값];
```

객체마다 저장할 필요가 없이 공용으로 선언하여 사용하기때문에 static 이면서 final로 선언이 된다. static final 필드는 객체마다 저장되지 않고 클래스에만 포함 된다. 그리고 한 번 초기값이 저장되면 변경할 수 없다.

상수 이름은 모두 대문자로 작성하는게 컨벤션이다. 만약 서로 다른 단어가 혼합된 이름이라면 언더바(_)로 단어들을 연결해 준다.

## 접근 제어자 (access modifier)

접근 제어자를 사용하여 변수나 메소드의 사용 권한을 설정할 수 있다.

<img width="789" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12 17 15" src="https://github.com/jeoongmiin/jeoongmiin.github.io/assets/100908119/c4eff631-92c3-491b-9c04-01fa863d2246">

| 접근 제어자 | 같은 클래스 | 같은 패키지 | 자식 클래스 | 전체 |
| --- | --- | --- | --- | --- |
| public | O | O | O | O |
| protected | O | O | O |  |
| default(packege-private) | O | O |  |  |
| private | O |  |  |  |

### 1. private

private이 붙은 변수나 메서드는 `해당 클래스 안에서만 접근이 가능` 하다.

### 2. default

접근 제어자를 별도로 설정하지 않는다면 변수나 메소드는 default 접근 제어자가 자동으로 설정되고 `동일한 패키지 안에서만 접근이 가능` 하다.

### 3. protected

protected가 붙은 변수나 메소드는 `동일 패키지의 클래스 또는 해당 클래스를 상속받은 클래스에서만 접근이 가능`하다.

### 4. public

public 접근 제어자가 붙은 변수나 메소드는 `어떤 클래스에서도 접근이 가능`하다. 

## Setter 메소드

객체의 데이터를 외부에서 마음대로 읽어들이고 수정할 경우 객체의 무결성이 깨질 수 있기 때문에 일반적으로 객체 지향 프로그래밍에서는 객체 외부에서 직접적으로 객체의 데이터에 접근 하는 것을 막는다.

객체 지향 프로그래밍에서는 이런 문제점을 해결하기 위해 메소드를 통해 데이터를 변경하는 방법을 선호한다. 데이터는 외부에서 접근할 수 없도록 막고, 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다.

Setter 메소드를 통해서 매개값을 검증해서 유효한 값만 데이터로 저장할 수 있게 한다.

```java
public class Car {
		private int speed;
		
		public void setSpeed(int speed) {
				if (speed < 0) {
						this.speed = 0;
				} else {
						this.speed = speed;
				}
		}
}
```

## Getter 메소드

외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는 것이 좋다. 객체 외부에서 객체의 필드값을 사용하기 부적절한 경우도 있는데 이런 경우에는 메소드로 필드값을 가공한 후 외부로 전달하면 된다.

```java
public class Car {
		private int speed;
		
		public double getSpeed() {
				double km = speed * 1.6;
				return km;
		}
}
```

클래스를 선언할 때 가능하면 필드를 private으로 선언해서 외부로부터 직접접근을 보호하고, 필드에 대한 Setter/Getter 메소드를 작성하여 필드값을 안전하게 변경/사용하는 것이 좋다.

![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10 42 01](https://github.com/jeoongmiin/jeoongmiin.github.io/assets/100908119/38bdfb7a-0f86-4671-b137-849f450ebf24)

만약 필드 타입이 boolean일 경우에는 관례상 get으로 시작하지 않고, is로 시작한다. 예를들어 stop 필드의 Getter와 Setter는 다음과 같이 작성할 수 있다.

```java
private boolean stop;

// Getter
public boolean **is**Stop() {
	return stop;
}

// Setter
public void setStop(boolean stop) {
	this.stop = stop;
}
```